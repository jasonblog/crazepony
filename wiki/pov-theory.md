

## CrazePOV介紹
旋轉時鐘（或稱POV-LED），也就是利用視覺暫留現象，通過一排（或數目有限）的LED燈快速地在一定區域重複掃過，來實現一個面的圖像或文字的顯示。相信很多有電子設計基礎、會寫單片機的朋友都做過。

筆者最初就是在一個宣講會上看到一位學長做的旋轉時鐘，從此便熱愛上了電子設計，並計劃著自己實現一個旋轉時鐘。通過學習和努力，最終完成了這一製作，在傳統的旋轉時鐘的基礎之上，也進行了一些改進，接下來便會同大家分享這一製作。筆者還有很多很有趣的點子，也會持續更新這個項目並實現這些點子。歡迎大家持續關注這個項目，有任何建議也歡迎告知筆者，讓我們一起完善這個有趣的東西！

![](/assets/img/pov.jpg)

<embed src="http://player.youku.com/player.php/sid/XNzM3MjE2Mjcy/v.swf" allowFullScreen="true" quality="high" width="480" height="400" align="middle" allowScriptAccess="always" type="application/x-shockwave-flash"></embed>


## 點陣數據提取原理及其改進
但就如同大多數人看到的一樣，由於旋轉時鐘是圓周形掃描，而現在大多數現有的圖片或文字的點陣提取軟件都是按照行或者列來進行掃描的。所以使用這些點陣提取軟件得到的數據在旋轉時鐘上面顯示出來的效果只會是一個看上去像是扇形的帶有一定畸變的圖形，並不能得到我們平時經常看到的正向顯示的效果。

根據旋轉時鐘的顯示原理：

![](/assets/img/pov-theory.png)

可以看到，要想解決圖像的畸變問題，只需要將需要顯示的圖片與顯示的點進行一一對應，如下圖所示：

![](/assets/img/pov-theory-2.jpg)

如果我們想要在旋轉時鐘上面顯示這隻兔斯基，那麼只需要兔斯基的輪廓覆蓋住的相應的點點亮就可以實現理想的顯示效果了。

旋轉時鐘的顯示原理不能改變，那麼可以做文章的就只有顯示的數據了。在進行點陣數據提取的時候，一般傳統的都是按照列或者行來提取數據，如下圖所示，其中圖片中的紫線代表正在掃描的位置，而箭頭代表掃描的方向：

![](/assets/img/pov-theory-3.jpg)

用這種方法掃描得到的點陣數據再通過旋轉時鐘進行顯示以後自然會出現類似扇形的畸變。那麼，我們反其道而行之，在掃描的時候根據旋轉時鐘顯示的掃描方向，亦即以圖片中心為原點，掃描線繞該原點旋轉360°進行點陣數據的提取，那麼最後通過旋轉時鐘顯示得到的圖片自然就是正常沒有畸變的圖片了。如下圖所示，其中圖片中的紫線代表正在掃描的位置，而箭頭代表掃描的方向：

![](/assets/img/pov-theory-4.jpg)

那麼，在弄明白原理和問題的解決辦法以後，就可以開始實踐了！利用MATLAB寫出相關代碼，就可以實現圖片的點陣數據的提取了。相關MATLAB代碼如下：

```
clear;
clc;

%定義掃描範圍是一個以450像素距離為半徑的圓
l = 450;

%定義掃描精度，此處為一圈掃描360次，也就是精度為1°，可根據需要自行靈活設置
num = 360;

%生成一個用以暫存數據的數組，由於每個數據是一個0~255的整數，故用個相應維數的向量表示就可以了
output = 1 : num;

%讀取圖片數據，此處因為一個500*500的圖片，且要顯示的內容在一個以450像素距離為半徑的圓內，可根據需要自行靈活設置
picture = uint8(255*ones(1000)) - imread('picture_1.bmp');

%以每1°為步進開始生成點陣數據
for m = 1 : num
%計算該時刻掃描線所處角度並計算x和y的變化量
a = (89 + m) * pi / 180; %前面加的89是為了重新設置起始掃描位置，以實現圖片的顯示方向，可根據需要自行靈活設置
    lx = l * cos(a);
    ly = l * sin(a);
    dx = lx / 31;
    dy = ly / 31;

    %確定掃描線的位置以後，以每個led為中心得到該處是否應該亮燈。值得注意的是，由於圖片像素較高，需要一個範圍內進行確認，此處是在一個5*5的巨星範圍內確認
    for n = 0 : 31
        if (      picture(fix(500 - ly + n*dy),fix(500 + lx - n*dx))...
                & picture(fix(501 - ly + n*dy),fix(500 + lx - n*dx)) & picture(fix(499 - ly + n*dy),fix(500 + lx - n*dx))...
                & picture(fix(500 - ly + n*dy),fix(501 + lx - n*dx)) & picture(fix(500 - ly + n*dy),fix(499 + lx - n*dx))...
                & picture(fix(502 - ly + n*dy),fix(500 + lx - n*dx)) & picture(fix(498 - ly + n*dy),fix(500 + lx - n*dx))...
                & picture(fix(500 - ly + n*dy),fix(502 + lx - n*dx)) & picture(fix(500 - ly + n*dy),fix(498 + lx - n*dx))...
                & picture(fix(501 - ly + n*dy),fix(501 + lx - n*dx)) & picture(fix(501 - ly + n*dy),fix(499 + lx - n*dx))...
                & picture(fix(499 - ly + n*dy),fix(501 + lx - n*dx)) & picture(fix(499 - ly + n*dy),fix(499 + lx - n*dx))...
                & picture(fix(502 - ly + n*dy),fix(502 + lx - n*dx)) & picture(fix(502 - ly + n*dy),fix(498 + lx - n*dx))...
                & picture(fix(498 - ly + n*dy),fix(502 + lx - n*dx)) & picture(fix(498 - ly + n*dy),fix(498 + lx - n*dx)) )
%生成二進制數據
output(m) = bitor(output(m) , 2 ^ n);
        end
    end
end

%以十六進制的形式保存得到的點陣數據
fid=fopen('OUTPUT.txt','w');
fprintf(fid,'0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,\n',output);
fclose(fid);
```
利用上段提取字模和圖片點陣數據的Matlab程序，對需要提取的圖片或者文字信息進行處理以後，就可以得到需要的數據了。下面是利用上訴程序得到的兔斯基這張圖片的數據

![](/assets/img/pov-data-matrix.jpg)

可以看到，每一組數據是由一個8位的十六進制數據構成，剛好是32位二進制數據，二進制“1”就代表是led要亮，“0”則代表滅。

## 單片機控制程序設計思路

在單片機控制程序方面需要的設計思路是利用光電傳感器或者霍爾傳感器（也可以使用諸如二維陀螺儀等傳感器，但是這種一般在設計自行車輪轂的POV等不方便設置參考點的時候才需要用到，筆者在這裡描述的POV主要是一個自制的單獨模塊，所以一般的光電傳感器或者或偶爾傳感器就可以滿足設計要求了）在基板旋轉到每一圈中的固定位置時，產生一個定位信號，並以此為基準開始每一度的掃描顯示。

![](/assets/img/pov-demo.jpg)

如上圖所示，在每轉一圈的同時進行計時，旋轉一圈得到的時間數據除以顯示精度（例如精度為1°時，就除以360）就可以得到掃描顯示間隔的時間，然後根據旋轉該圈起始時間和當前時刻就可以得到基板當前的實際位置，然後根據數據對應顯示該位置應顯示的內容即可。

有一點值得注意，若使用的單片機的緩存（ram）較大，可以設置一個顯示緩存，掃描顯示的時候顯示的就是這個緩存裡面的數據，需要變換圖像的時候只需要更新緩存裡面的數據即可。

顯示控制的程序流程圖：

![](/assets/img/pov-flow-graph.jpg)

## 硬件環境的搭建
要實際做出一個旋轉時鐘，少了實物製作當然是不行的，旋轉時鐘的系統框圖如下所示：

![](/assets/img/pov-hardware-graph.jpg)

其中，具體需要注意的有以下幾點：

* 微控制器的選取

由於要儲存大量的圖像信息（例如，以筆者試做的旋轉時鐘為例，取精度為1°，有單色的led共32只，那麼在不考慮數據壓縮的情況下，旋轉一週所顯示的圖片的數據量為：360*32=11520 bit=1440 Byte，假如加入數字時鐘等需要存入預定數據的應用，那麼至少需要存儲2+10+7+10=29張圖片（由於位置的不同，和應用的特殊性，每個不同的位置的不同數字都需要單獨的數據），也就是29*1440=41760 Byte的數據，筆者在編寫程序的時候，消除了一定的冗餘，但是最終的數據量也達到了20KB，顯然，一般的單片機不能滿足要求），所以微控制器的ROM不能太小，而且需要具備外部中斷和定時器的基本功能。筆者之前試做的一個樣品使用的控制芯片是MSP430F149，同樣也可以考慮功能更強大的STM32F103系列，該系列有大容量的器件，還可以通過增加藍牙等通訊模塊來實現數據的實時透傳，筆者後期也會考慮使用arduino等用戶群體較大的器件；

* 電機的選取

轉速不能太慢，否則顯示會出現人眼可見的閃爍；但也不能太快，不然旋轉的板子可能會產生脫落，搖晃等危險。故轉速在2000rpm左右比較合適，最好是根據電壓可調轉速的。筆者之前試做的一個樣品使用的電機是一個9V-12V可調，轉速在2000rpm左右的直流電機；

* 供電方式的選取

具體來講主要有電池供電、電刷供電、無線傳能這三種方法。無線傳能的實現難度比較大，而且效率較低，所以不予考慮；電池供電雖然簡便，但是在旋轉基板上面安裝電池以後配重問題比較難解決，而且高速旋轉可能導致電池飛出，所以也不予考慮；電刷供電雖然是機械式的供電方式，有機械損耗等問題，但是綜合起來時比較靠譜的方案，所以筆者最終選用了電刷供電的供電方式。

![](/assets/img/pov-brush-power.jpg)

如上圖所示電機軸芯是與電機的供電電路絕緣的，所以可以用作旋轉基板的供電（GND），在軸芯外面裹上一層熱縮管用以絕緣，在套上一個銅套就可以用作基板的電源（VCC）供電。電刷只需要分別與銅套和轉軸接觸就可以實現旋轉基板的供電。

* 定位方式的選取

在基板旋轉到定位點以後，需要一個脈衝信號，用以標記零點位置並重置計數數據，方便在接下來的一圈中準確地對基板的實時位置經行定位。一般來說，主要有霍爾傳感器和光電傳感器兩種方式，這兩種方式基本都差不多，任選一種方式即可。筆者之前試做的一個樣品使用的是光電傳感器的方式。如果在不方便安置磁鋼或者擋光片的情況下，也可以考慮使用二維陀螺儀等傳感器；

* 旋轉基板的配重
由於在旋轉時鐘工作的時候，旋轉基板是高速旋轉的，所以需要對旋轉基板進行配重，使其能夠平穩地工作。具體做法為：可以再旋轉基板的兩頭預留一些孔位，根據重量在合適的位置添加銅柱以使基板的重心在旋轉中心處；

基本上，進行實物製作的時候需要注意的就有以上幾點。由於筆者在進行實驗樣品的實物製作的時候選擇的是利用洞洞板和跳線手焊的方式，而電路圖比較簡單，也沒有具體畫出電路原理圖或者繪製出PCB板，所以具體制作過程在此略過。但是，筆者正在製作一個可以實現RGB彩色顯示的旋轉時鐘，而且正在設計相關的PCB板，預計2014年暑期就可以完成。而且該項目是一個開源項目，如果你對此項目感興趣的話，歡迎關注其進展情況。

下面就是筆者製作的旋轉時鐘的實物圖：

![](/assets/img/pov-demo-1.jpg)

![](/assets/img/pov-demo-2.jpg)

利用前面提到的提取字模和圖片點陣數據的原理，通過Matlab編寫相關程序，對需要提取的圖片或者文字信息進行處理以後，把數據燒寫到單片機中，便可以得到理想的效果。

下面是一些最終效果的展示：

![](/assets/img/pov-demo-3.jpg)

![](/assets/img/pov-demo-4.jpg)

![](/assets/img/pov-demo-5.jpg)

![](/assets/img/pov-demo-6.jpg)

## 寫在最後
這個旋轉時鐘是筆者在前年，也就是2012年10月的時候幫做硬件的隊友做出來當做生日禮物送給他姐姐的。由於那個時候專業知識還不夠完善，沒有學習PCB設計，所以無奈只能選擇手焊的方式（真的是太痛苦了。。。），所以製作也不算精良。

筆者在寫這篇文章的時候由於一些契機，將這個趣味製作翻了出來分享給大家，再加上筆者之前的一些奇思妙想，有了製作RGB彩色旋轉顯示系統的想法，而且經過這期間的學習，筆者已經會繪製PCB板了。所以，我也在繼續完善這個項目，預計2014年暑期就可以完成RGB彩色旋轉顯示系統，下面是我已經完成設計的PCB板（正在工廠經行加工，很快就可以拿到實物了）的展示：

![](/assets/img/pov-pcb-1.png)

![](/assets/img/pov-pcb-2.png)

![](/assets/img/pov-pcb-3.png)

![](/assets/img/pov-pcb-4.png)

考慮到光心的準確重合，採用了RGB三個葉片狀的設計，同時也突破了旋轉時鐘一貫的長條形外形風格。而且將供電模塊，無線模塊還有時鐘模塊全部和在一起畫在另一層板子上面，同控制顯示模塊（即最大的那塊板子）分立開來，不僅簡化了佈局佈線，方便修改板子，也在一定程度上解決了配重的問題。由於主要的顯示控制板採用三葉設計，比較像一個三葉螺旋槳，這也是這個項目名字CrazePOV的由來。當然，它肯定不能飛啦~（笑）

該系統不僅可以像前述旋轉時鐘一樣無畸變地顯示圖片和文字，還可以實現彩色圖片的顯示，理論上可以完成一些簡單動畫的播放，筆者還將加入藍牙模塊，以實現動畫或者圖片的實時顯示。如果你對筆者的這一項目感興趣，歡迎關注筆者的進展，相信一定不會令你失望的！


